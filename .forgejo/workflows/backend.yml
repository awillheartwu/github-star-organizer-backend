name: Backend CI

concurrency:
  group: backend-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'prisma/**'
      - 'test/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'tsconfig*.json'
      - '.forgejo/workflows/backend.yml'
      - 'Dockerfile'
      - 'docker-compose.yml'
  pull_request:
    branches: [main]
    paths:
      - 'src/**'
      - 'prisma/**'
      - 'test/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'tsconfig*.json'
      - '.forgejo/workflows/backend.yml'
      - 'Dockerfile'
      - 'docker-compose.yml'

jobs:
  build-and-test:
    runs-on: [self-hosted, linux, docker]
    container: node:22-slim
    env:
      NODE_ENV: test
      DATABASE_URL: ${{ secrets.GSOR_DATABASE_URL }}
      TEST_DATABASE_URL: ${{ secrets.GSOR_TEST_DATABASE_URL }}
      REDIS_HOST: ${{ secrets.GSOR_REDIS_HOST }}
      REDIS_PORT: ${{ secrets.GSOR_REDIS_PORT }}
      REDIS_PASSWORD: ${{ secrets.GSOR_REDIS_PASSWORD }}
      GITHUB_TOKEN: ${{ secrets.GSOR_GITHUB_TOKEN }}
      AI_API_KEY: ${{ secrets.GSOR_AI_API_KEY }}
      JWT_ACCESS_SECRET: ${{ secrets.GSOR_JWT_ACCESS_SECRET }}
      JWT_REFRESH_SECRET: ${{ secrets.GSOR_JWT_REFRESH_SECRET }}

      # 非敏感变量，直接内联
      PORT: 3999
      FASTIFY_CLOSE_GRACE_DELAY: 200
      LOG_LEVEL: silent
      CORS_ORIGIN: '*'
      CORS_CREDENTIALS: false
      TRUST_PROXY: false
      BODY_LIMIT: 1048576
      HELMET_CSP: false

      JWT_ACCESS_EXPIRES: 15m
      JWT_REFRESH_EXPIRES: 7d
      AUTH_COOKIE_NAME: rt
      AUTH_COOKIE_SECURE: false
      AUTH_COOKIE_SAME_SITE: lax
      AUTH_ALLOW_REGISTRATION: true

      RATE_LIMIT_WINDOW: 60000
      RATE_LIMIT_MAX: 20

      BULL_PREFIX: gsor-test
      BULL_ROLE: producer

      GITHUB_USERNAME: dummy
      SYNC_STARS_CRON: '0 5 * * *'
      SYNC_CONCURRENCY: 1
      SYNC_JOB_ATTEMPTS: 1
      SYNC_JOB_BACKOFF_MS: 1000
      SYNC_PER_PAGE: 10
      SYNC_MAX_PAGES: 0
      SYNC_SOFT_DELETE_UNSTARRED: false
      SYNC_REQUEST_TIMEOUT: 1000

      NOTIFY_EMAIL_ENABLED: false

      RT_EXPIRED_CLEAN_AFTER_DAYS: 0
      RT_REVOKED_RETENTION_DAYS: 7
      RT_CLEAN_BATCH: 100
      RT_CLEAN_DRY_RUN: true
      BULL_DRY_RUN: true
      BULL_CLEAN_COMPLETED_AFTER_DAYS: 3
      BULL_CLEAN_FAILED_AFTER_DAYS: 30
      BULL_TRIM_EVENTS: 500
      MAINT_ENABLED: false
      MAINT_CRON: '0 3 * * *'

      AI_SUMMARY_MIN_INTERVAL_MS: 1000
      AI_SUMMARY_ATTEMPTS: 1
      AI_SUMMARY_BACKOFF_MS: 500
      AI_SUMMARY_CONCURRENCY: 1
      AI_SUMMARY_CRON: '0 4 * * *'
      AI_SUMMARY_SCAN_ENABLED: true
      AI_SUMMARY_BATCH_SIZE: 50
      AI_SUMMARY_REGENERATE_DAYS: 1
      AI_SUMMARY_INITIAL_BACKFILL_DAYS: 30
      AI_SUMMARY_STALE_DAYS: 1
      AI_README_MAX_CHARS: 1000
      AI_RPM_LIMIT: ''

      BULL_UI_ENABLED: true
      BULL_UI_PATH: /admin/queues/ui
      BULL_UI_READONLY: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Ensure test database url
        shell: bash
        run: |
          if [[ -z "${TEST_DATABASE_URL}" && -n "${DATABASE_URL}" ]]; then
            echo "TEST_DATABASE_URL=${DATABASE_URL}" >> "$GITHUB_ENV"
          fi

      - name: Generate Prisma client
        run: pnpm prisma generate

      - name: Lint
        run: pnpm lint

      - name: Run unit tests
        run: pnpm test

      - name: Compile TypeScript
        run: pnpm build

  build-image:
    name: Build container image
    needs: build-and-test
    runs-on: [self-hosted, linux, docker]
    steps:
      - uses: actions/checkout@v4

      - name: Install Docker CLI
        run: |
          # 检查是否已安装 Docker CLI
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker CLI..."
            # 创建本地 bin 目录
            mkdir -p ~/bin
            # 下载并安装 Docker CLI
            curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-20.10.24.tgz | tar xz
            cp docker/docker ~/bin/
            rm -rf docker
            chmod +x ~/bin/docker
            # 添加到 PATH
            echo "$HOME/bin" >> $GITHUB_PATH
            export PATH="$HOME/bin:$PATH"
          fi
          
          # 验证 Docker CLI 安装
          ~/bin/docker --version || docker --version

      - name: Build Docker image
        run: |
          # 确保 Docker CLI 在 PATH 中
          export PATH="$HOME/bin:$PATH"
          # 设置 Docker 环境变量并构建镜像
          export DOCKER_HOST=tcp://docker-dind:2375
          export DOCKER_TLS_CERTDIR=""
          
          # 等待 Docker daemon 可用
          for i in {1..30}; do
            if docker version >/dev/null 2>&1; then
              echo "Docker daemon is ready"
              break
            fi
            echo "Waiting for Docker daemon... ($i/30)"
            sleep 2
          done
          
          # 构建镜像
          docker build -f Dockerfile -t backend-ci:latest .

      - name: Test image
        run: |
          # 确保 Docker CLI 在 PATH 中
          export PATH="$HOME/bin:$PATH"
          # 验证镜像构建成功
          export DOCKER_HOST=tcp://docker-dind:2375
          export DOCKER_TLS_CERTDIR=""
          docker images backend-ci:latest

  deploy:
    name: Deploy to NAS (self-hosted)
    needs: [build-and-test, build-image]
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, linux, docker]
    env:
      ENV_PRODUCTION: ${{ secrets.GSOR_ENV_PRODUCTION }}
    steps:
      - uses: actions/checkout@v4

      - name: Install Docker CLI (if needed)
        run: |
          # 检查是否已安装 Docker CLI
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker CLI..."
            # 创建本地 bin 目录
            mkdir -p ~/bin
            # 下载并安装 Docker CLI
            curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-20.10.24.tgz | tar xz
            cp docker/docker ~/bin/
            rm -rf docker
            chmod +x ~/bin/docker
            # 添加到 PATH
            echo "$HOME/bin" >> $GITHUB_PATH
            export PATH="$HOME/bin:$PATH"
          fi
          
          ~/bin/docker --version || docker --version

      - name: Write .env.production
        run: printf '%s\n' "${ENV_PRODUCTION}" > .env.production

      - name: Deploy with Docker Compose
        run: |
          # 确保 Docker CLI 在 PATH 中
          export PATH="$HOME/bin:$PATH"
          # 设置环境变量
          export DOCKER_HOST=tcp://docker-dind:2375
          export DOCKER_TLS_CERTDIR=""
          
          # 等待 Docker daemon 可用
          for i in {1..30}; do
            if docker version >/dev/null 2>&1; then
              echo "Docker daemon is ready"
              break
            fi
            echo "Waiting for Docker daemon... ($i/30)"
            sleep 2
          done
          
          # 部署应用
          docker compose -f docker-compose.yml down --remove-orphans || true
          docker compose -f docker-compose.yml up -d --build

      - name: Wait for health
        run: |
          # 等待容器启动
          sleep 15
          
          for i in {1..30}; do
            if curl -fsS http://127.0.0.1:3030/healthz >/dev/null 2>&1; then
              echo "Service is healthy"; exit 0
            fi
            echo "Waiting for service... ($i/30)"; sleep 2
          done
          echo "Service failed to become healthy" >&2
          
          # 显示日志
          export PATH="$HOME/bin:$PATH"
          export DOCKER_HOST=tcp://docker-dind:2375
          export DOCKER_TLS_CERTDIR=""
          docker compose logs --no-color || true
          exit 1